	private List<CountryDTO> convertCountriesToDTOs(List<Country> countries) {
		List<CountryDTO> retVal = new ArrayList<>();
	
		return countries.stream()
				.map(this::createDTO) //country -> createDTO(country)
				.collect(Collectors.toList());
				
		/*
		for (Country country: countries) {
			CountryDTO countryDTO = new CountryDTO(country); 
			// popunjavanje i kolekcije gradova u DTO objektu
			for (Place city: country.getPlaces()) {
				countryDTO.getPlaces().add(new PlaceDTO(city));
			}
			retVal.add(countryDTO);
		}*/
		//return retVal;
	}
	
	private CountryDTO createDTO(Country country) {
		
		CountryDTO dto = new CountryDTO(country);
		
		List<PlaceDTO> places =	country.getPlaces().stream()
			.map(PlaceDTO::new) //place -> new PlaceDTO(place)
			.collect(Collectors.toList());
	
		dto.setPlaces(places);
	
		return dto;
	}

-- country service
	public Optional<Country> findOne(Long id) {
		return countryRepository.findById(id);
	}

-- goto countrycintroller
@RequestMapping(value = "api/countries/{id}", method = RequestMethod.GET)
	public ResponseEntity<CountryDTO> getCountry(@PathVariable Long id) {
//		Country country = countryService.findOne(id);
//		
//		if (country != null) {
//			CountryDTO countryDTO = new CountryDTO(country);
//			// popunjavanje i kolekcije gradova u DTO objektu
//			for (Place city: country.getPlaces()) {
//				countryDTO.getPlaces().add(new PlaceDTO(city));
//			}			
//			return new ResponseEntity<>(countryDTO, HttpStatus.OK);
//		} else {
//			return new ResponseEntity<>(HttpStatus.NOT_FOUND);
//		}
		
	return	countryService.findOne(id)
		.map(country -> createDTO(country))
		.map(dto -> new ResponseEntity<>(dto, HttpStatus.OK))
		.orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
	}